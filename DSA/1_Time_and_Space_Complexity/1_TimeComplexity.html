<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Complexity</title>
</head>
<body>
    <pre>
        ->Time Complexity?
            It measures how the runtime of an algorithm grows as the input size(n) increases.
            1) O(1) : Constent time.
            2) O(n) : Linear time.
            3) O(n^2) : Quadratic time.

    1️⃣ What They Are
        Concept	Meaning
        Time Complexity: How the running time of an algorithm increases as the input size n grows.
        Space Complexity: How the memory used by an algorithm increases as the input size n grows.

    2️⃣ Time Complexity Basics
        We use Big-O notation to describe the upper bound (worst-case) growth.
        Common complexities:
            Big-O	       Name	               Example
            O(1)	     Constant	       Accessing an array index
            O(log n)	 Logarithmic	   Binary search
            O(n)	     Linear	           Iterating once over an array
            O(n log n)	 Log-linear	       Merge sort
            O(n²)	     Quadratic	       Nested loops over an array
            O(2^n)	     Exponential	   Recursive subset generation
            O(n!)	     Factorial	       Brute-force traveling salesman


    3️⃣ Tradeoff: Time vs Memory
        Sometimes you can reduce time but use more memory (e.g. caching results in React state, memoizing expensive computations).
        Sometimes you save memory but take more time (e.g. recomputing values instead of storing them).

    ➡️Quick Summary (Frontend Angle)
        Use Big-O to reason about scalability of your UI logic.
        Nested loops (O(n²)) are expensive → avoid them when handling DOM updates or big lists.
        Time vs Space tradeoff:
        Memoization / caching in React → better time, more memory.
        Recompute each time → saves memory, costs time.
        for vs map: both O(n), but map uses more memory since it always creates a new array.
        for vs map:
            Both are O(n) in time complexity.
             But map() internally creates a new array → uses extra O(n) space, while for gives you more control (you can modify in-place for O(1) space).
             On very large arrays (say 10M items), a plain for loop can sometimes be slightly faster since it avoids some overhead of callbacks. But readability-wise, map is better.
    </pre>
    <script>
        // -> O(1) : Constant Time (Here execution doesn't depend on input size):
            function getFirst(arr){
                return arr[0]
            }
           // Fast, no matter if arr has 10 elements or 10 million elements it always returns first only

        // -> O(n) : Linear Time (Here execution/runtime grows directly with input size)
        function printAll(arr){
            arr.forEach((el)=>console.log(el))
        } //If array size doubles the operation also doubles

        // -> O(n^2) : Quadration time (Here we have nested loops over the same data which increases the runtime)
        function printPairs(arr){
            for(let i=0;i<arr.length;i++){
                for(let j=0;j<arr.length;j++){
                    console.log(aee[i],arr[j]) // n*n operations
                }
            }
        } //Here if input is 100 elements i.e means 10000 elements

        //More examples and info on next time 2_TimeComplexity.js
        
        
    </script>
</body>
</html>